//
//  Client.m
//  CrossAreaDesignPatternCompare
//
//  Created by User on 2019/3/14.
//  Copyright © 2019年 User. All rights reserved.
//
/*
 跨战区PK
 1.创建类模式描述如何创建对象，行为类模式关注如何管理对象的行为，结构类模式则着重于如何建立一个软件结构
 2.虽然三种模式的着重点不同，但是在实际应用中还是有重叠的，会出现一种模式适用、另外一种模式也适用的情况，我们到底该选用哪一个设计模式呢
 
 策略模式VS桥梁模式
  1.两者之间确实很相似。如果把策略模式的环境角色变更为一个抽象类加一个实现类，或者桥梁模式的抽象角色未实现，只有修正抽象化角色
  2.这两个类图有什么地方不一样？完全一样！正是由于类似场景的存在才导致了两者在实际应用中经常混淆的情况发生
  3.策略模式与桥梁模式是如此相似，简直就是孪生兄弟，要把它们两个分开可不太容易
  4.策略模式是行为型模式，桥梁模式是结构型模式
  5.桥梁模式关注的是抽象和实现的分离，它是结构型模式，结构型模式研究的是如何建立一个软件架构
 最佳实践
  1.策略模式是一个行为模式，旨在封装一系列的行为，在例子中我们认为把邮件的必要信息（发件人、收件人、标题、内容）封装成一个对象就是一个行为，封装的格式（算法）不同，行为也就不同。
  2.桥梁模式则是解决在不破坏封装的情况下如何抽取出它的抽象部分和实现部分，它的前提是不破坏封装，让抽象部分和实现部分都可以独立地变化，在例子中，我们的邮件服务器和邮件模板是不是都可以独立地变化？不管是邮件服务器还是邮件模板，只要继承了抽象类就可以继续扩展，它的主旨是建立一个不破坏封装性的可扩展架构
  3.策略模式是使用继承和多态建立一套可以自由切换算法的模式
  4.桥梁模式是在不破坏封装的前提下解决抽象和实现都可以独立扩展的模式
  6.桥梁模式必然有两个“桥墩”——抽象化角色和实现化角色，只要桥墩搭建好，桥就有了
  7.策略模式只有一个抽象角色，可以没有实现，也可以有很多实现
  8.多想想两者的意图，就可以理解为什么要建立两个相似的模式了。我们在做系统设计时，可以不考虑到底使用的是策略模式还是桥梁模式，只要好用，能够解决问题就成，“不管黑猫白猫，抓住老鼠的就是好猫
 
 门面模式VS中介者模式
  1.门面模式为复杂的子系统提供一个统一的访问界面，它定义的是一个高层接口，该接口使得子系统更加容易使用，避免外部模块深入到子系统内部而产生与子系统内部细节耦合的问题
  2.中介者模式使用一个中介对象来封装一系列同事对象的交互行为，它使各对象之间不再显式地引用，从而使其耦合松散，建立一个可扩展的应用架构
 
 最佳实践
 门面模式和中介者模式之间的区别还是比较明显的
    1.门面模式是以封装和隔离为主要任务
    2.中介者模式则是以调和同事类之间的关系为主，因为要调和，所以具有了部分的业务逻辑控制
 两者的主要区别如下：
 ● 功能区别
    1.面模式只是增加了一个门面，它对子系统来说没有增加任何的功能，子系统若脱离门面模式是完全可以独立运行的
    2.中介者模式则增加了业务功能，它把各个同事类中的原有耦合关系移植到了中介者，同事类不可能脱离中介者而独立存在，除非是想增加系统的复杂性和降低扩展性
 ● 知晓状态不同
    1.对门面模式来说，子系统不知道有门面存在
    2.对中介者来说，每个同事类都知道中介者存在，因为要依靠中介者调和同事之间的关系，它们对中介者非常了解
 ● 封装程度不同
    1.门面模式是一种简单的封装，所有的请求处理都委托给子系统完成
    2.中介者模式则需要有一个中心，由中心协调同事类完成，并且中心本身也完成部分业务，它属于更进一步的业务功能封装
 
 包装模式群PK
  1.我们讲了这么多的设计模式，大家有没有发觉在很多的模式中有些角色是不干活的？它们只是充当黔首作用，你有问题，找我，但我不处理，我让其他人处理
  2.最典型的就是代理模式了，代理角色接收请求然后传递到被代理角色处理
  3.门面模式也是一样，门面角色的任务就是把请求转发到子系统
  4.类似这种结构的模式还有很多，我们先给这种类型的模式定义一个名字，叫做包装模式（wrapping pattern）
  5.注意，包装模式是一组模式而不是一个
  6.包装模式包括：装饰模式、适配器模式、门面模式、代理模式、桥梁模式 (结构类型模式)
 最佳实践
  1.5个包装模式是大家在系统设计中经常会用到的模式
  2.它们具有相似的特征：都是通过委托的方式对一个对象或一系列对象（例如门面模式）施行包装，有了包装，设计的系统才更加灵活、稳定，并且极具扩展性
  3.从实现的角度来看，它们都是代理的一种具体表现形式，我们来看看它们在使用场景上有什么区别
  4.代理模式主要用在不希望展示一个对象内部细节的场景中，比如一个远程服务不需要把远程连接的所有细节都暴露给外部模块，通过增加一个代理类，可以很轻松地实现被代理类的功能封装
  5.代理模式还可以用在一个对象的访问需要限制的场景中，比如AOP （构建代理，让代理无所不能）
  6.装饰模式是一种特殊的代理模式，它倡导的是在不改变接口的前提下为对象增强功能，或者动态添加额外职责
  7.装饰模式就扩展性而言，它比子类更加灵活，例如在一个已经运行的项目中，可以很轻松地通过增加装饰类来扩展系统的功能（构建继承同一个接口， 主要用于增强或削弱功能）
  8.适配器模式的主要意图是接口转换，把一个对象的接口转换成系统希望的另外一个接口，这里的系统指的不仅仅是一个应用，也可能是某个环境，比如通过接口转换可以屏蔽外界接口，以免外界接口深入系统内部，从而提高系统的稳定性和可靠性 （更加目标对象，使用现有的对象进行转换，主要是通过目标对象的接口来进行这中转换）
  9.桥梁模式是在抽象层产生耦合，解决的是自行扩展的问题，它可以使两个有耦合关系的对象互不影响地扩展
  10.桥梁模式，比如对于使用笔画图这样的需求，可以采用桥梁模式设计成用什么笔（铅笔、毛笔）画什么图（圆形、方形）的方案，至于以后需求的变更，如增加笔的类型，增加图形等，对该设计来说是小菜一碟。
  11.门面模式是一个粗粒度的封装，它提供一个方便访问子系统的接口，不具有任何的业务逻辑，仅仅是一个访问复杂系统的快速通道，没有它，子系统照样运行，有了它，只是更方便访问而已（仅仅是封装成一个对外暴露的简单调用接口，其内部怎么实现不会暴露）
*/

#import "Client.h"

#import "Strategy/MailServer.h"
#import "Strategy/TextMail.h"
#import "Strategy/HtmlMail.h"

#import "Bridge/Postfix.h"
#import "Bridge/BTextMail.h"
#import "Bridge/BHtmlMail.h"

#import "Mediator/Mediator.h"
#import "Mediator/Position.h"
#import "Mediator/Tax.h"
#import "Mediator/Salary.h"

#import "Facade/HRFacade.h"

#import "WrappingPatternCompare/Proxy/Idolater.h"

#import "WrappingPatternCompare/Decoration/FreakStar.h"
#import "WrappingPatternCompare/Decoration/HotAir.h"
#import "WrappingPatternCompare/Decoration/Deny.h"

#import "WrappingPatternCompare/Adapter/Director.h"

#import "WrappingPatternCompare/Bridge/ActFilm.h"
#import "WrappingPatternCompare/Bridge/Sing.h"
#import "WrappingPatternCompare/Bridge/BFilmStar.h"
#import "WrappingPatternCompare/Bridge/BSinger.h"

@implementation Client

+ (void)execute
{
    /*
     策略模式
     这里的策略，是对Text和Html两种格式进行了封装
     很简单，邮件服务器接收了一封邮件，然后调用自己的发送程序进行发送。可能读者要问了，为什么不把sendMail方法移植到邮件模板类中呢？这也是邮件模板类的一个行为，邮件可以被发送。是的，这确实是邮件的一个行为，完全可以这样做，两者没有什么区别，只是从不同的角度看待该方法而已
     
     在该场景中，我们使用策略模式实现两种算法的自由切换，它提供了这样的保证：封装邮件的两种行为是可选择的，至于选择哪个算法是由上层模块决定的。策略模式要完成的任务就是提供两种可以替换的算法
     */
//    MailTemplate *m = [[HtmlMail alloc] initWithFrom:@"a@com"
//                                                  to:@"b@com"
//                                             subject:@"GOGOGOG"
//                                             context:@"LALALALALALA"];
//    MailServer *server = [[MailServer alloc] initWithM:m];
//    [server sendMail];
    
    /*
     桥梁模式
     该类相对于策略模式的环境角色有两个改变：
     ● 修改为抽象类。为什么要修改成抽象类？因为我们在设计一个架构，邮件服务器是一个具体的、可实例化的对象吗？“给我一台邮件服务器”能实现吗？不能，只能说“给我一台Postfix邮件服务器”，这才能实现，必须有一个明确的可指向对象。
     ● 变量m修改为Protected访问权限，方便子类调用。
     这里的桥梁是用在对 进行了BMailServer抽象和扩展
     */
//    BMailTemplate *m = [[BHtmlMail alloc] initWithFrom:@"a@a.com"
//                                                    to:@"b@b.com"
//                                               subject:@"WAWAAW"
//                                               context:@"SKSKSKSKSKSK"];
//    BMailServer *mail = [[Postfix alloc] initWithM:m];
//    [mail sendMail];
    
    /*
     中介者模式
        它的12个方法分为两大类型：一类是每个业务的独立流程，比如增加工资，仅仅实现单独增加工资的职能，而不关心职位、税收是如何变化的，该类型的方法是private私有类型，只能提供本类内访问；另一类是实现抽象中介者定义的方法，完成具体的每一个逻辑，比如职位上升，同时也引起了工资增加、税收增加。我们编写一个场景类，看看运行结果
      1.我们回过头来分析一下设计，在接收到需求后我们发现职位、工资、税收之间有着紧密的耦合关系，如果不采用中介者模式，则每个对象都要与其他两个对象进行通信，这势必会增加系统的复杂性，同时也使系统处于僵化状态，很难实现拥抱变化的理想。
      2.通过增加一个中介者，每个同事类的职位、工资、税收都只与中介者通信，中介者封装了各个同事类之间的逻辑关系，方便系统的扩展和维护。
     全部放到中介者中处理, 各个角色调用自己的方法，该方法内部调用中介者去处理该角色分配的任务，角色知道中介者的存在，中介者也知道角色的存在
     */
//    Mediator *mediator = [Mediator new];
//    id<IPosition> position = [[Position alloc] initWithMediator:mediator];
//    id<ISalary> salary = [[Salary alloc] initWithMediator:mediator];
//    id<ITax> tax = [[Tax alloc] initWithMediator:mediator];
//
//    [position promote];
//    [salary increaseSalary];
//    [tax drop];
    
    
    /*
     门面模式
     1.工资计算是一件非常复杂的事情，简单来说，它是对基本工资、月奖金、岗位津贴、绩效、考勤、税收、福利等因素综合运算后的一个数字。即使设计一个HR（人力资源）系统，员工工资计算也是非常复杂的模块，但是对于外界，比如高管层，最希望看到的结果是张三拿了多少钱，李四拿了多少钱，而不是看中间的计算过程，怎么计算那是人事部门的事情。换句话说，对外界的访问者来说，它只要传递进去一个人员名称和月份即可获得工资数，而不用关心其中的计算有多么复杂，这就用得上门面模式了
     2.在该例中，我们使用了门面模式对薪水计算子系统进行封装，避免子系统内部复杂逻辑外泄，确保子系统的业务逻辑的单纯性，即使业务流程需要变更，影响的也是子系统内部功能，比如奖金需要与基本工资挂钩，这样的修改对外系统来说是透明的，只需要子系统内部变更即可
     门面中包含子系统， 内部调用子系统去得到一个结果，子系统可以脱离门面而单独存在，子系统不需要知道门面的存在
     */
//    HRFacade *hr = [HRFacade new];
//    NSInteger salary = [hr querySalary:@"XX" date:[NSDate date]];
//    NSLog(@"Salary: %ld", salary);
//    NSInteger workDays = [hr queryWorksDays:@"XX"];
//    NSLog(@"WorkDays: %ld", workDays);
    
    /*
     代理模式
     看看我们的程序逻辑，我们是找明星的经纪人签字，真实签字的是明星，经纪人只是把这个请求传递给明星处理而已，这是普通的代理模式的典型应用。
     */
//    Idolater *idolater = [Idolater new];
//    [idolater starchaser];
    
    /*
     装饰模式
     */
//    id<IDStar> freakStar = [FreakStar new];
//    freakStar = [[HotAir alloc] initWithStar:freakStar];
//    freakStar = [[Deny alloc] initWithStar:freakStar];
//    [freakStar act];
    
    /*
     适配器模式
     这里使用了适配器模式，把一个普通的演员转换为一个明星演员
     */
//    Director *director = [Director new];
//    [director direct];
    
    /*
     桥梁模式
     好了，各类明星都有自己的本职工作，但是偶尔客串一个其他类型的活动也是允许的，如此设计后，明星就可以不用固定在自己的本职工作上，而是向其他方向发展，比如影视歌三栖明星。
     */
    AbsStar *lk = [BFilmStar new];
    AbsStar *ls = [BSinger new];
    [ls doJob];
    [lk doJob];
    
    ls = [[BSinger alloc] initWithAction:[ActFilm new]];
    [ls doJob];
}

@end
